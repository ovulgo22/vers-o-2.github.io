<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Beehive Simulation</title>
    <style>
        body {
            background-color: #1a2833;
            color: #ecf0f1;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            overflow: hidden;
        }
        h1 {
            margin: 5px 0 10px 0;
            font-weight: 300;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.4);
        }
        #simulationContainer {
            position: relative;
            border: 2px solid #f1c40f;
            box-shadow: 0 0 25px rgba(241, 196, 15, 0.4);
            background-color: #34495e; /* Fallback for no JS */
        }
        #bgCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
        #mainCanvas {
            position: relative;
            z-index: 1;
        }
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.4);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.9em;
            pointer-events: none;
            z-index: 2;
        }
        #stats p {
            margin: 2px 0;
        }
        #stats span {
            font-weight: bold;
            color: #f1c40f;
        }
        #controls {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            padding: 10px 20px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 10px;
            width: 90%;
            max-width: 900px;
            justify-content: center;
            align-items: center;
        }
        .slider-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-grow: 1;
        }
        label {
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        .value-display {
            font-weight: bold;
            color: #f1c40f;
            min-width: 30px;
            text-align: center;
        }
        button {
            padding: 8px 15px;
            background-color: #f1c40f;
            border: none;
            color: #2c3e50;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #f39c12;
        }
    </style>
</head>
<body>

    <h1>Advanced Beehive Simulation</h1>

    <div id="simulationContainer">
        <canvas id="bgCanvas"></canvas>
        <canvas id="mainCanvas"></canvas>
        <div id="stats"></div>
    </div>

    <div id="controls">
        <div class="slider-group">
            <label for="colonySize">Initial Colony Size</label>
            <div>
                <input type="range" id="colonySize" min="10" max="150" value="50">
                <span class="value-display" id="colonyValue">50</span>
            </div>
        </div>
        <div class="slider-group">
            <label for="resourceAvailability">Resource Availability</label>
            <div>
                <input type="range" id="resourceAvailability" min="1" max="10" value="5">
                <span class="value-display" id="resourceValue">5</span>
            </div>
        </div>
        <button id="resetButton">Reset</button>
    </div>

<script>
    // --- DOM ELEMENTS ---
    const bgCanvas = document.getElementById('bgCanvas');
    const mainCanvas = document.getElementById('mainCanvas');
    const statsDiv = document.getElementById('stats');
    const colonySizeSlider = document.getElementById('colonySize');
    const resourceSlider = document.getElementById('resourceAvailability');
    const colonyValueSpan = document.getElementById('colonyValue');
    const resourceValueSpan = document.getElementById('resourceValue');
    const resetButton = document.getElementById('resetButton');

    const bgCtx = bgCanvas.getContext('2d');
    const mainCtx = mainCanvas.getContext('2d');

    // --- CONFIGURATION ---
    const CONFIG = {
        HEX_SIZE: 18,
        BEE_SIZE: 3.5,
        BEE_SPEED: 2.0,
        QUEEN_SPEED: 0.5,
        BUILD_SPEED: 0.5,
        TEND_SPEED: 0.4,
        EGG_LAY_CHANCE: 0.005,
        HATCH_TIME: 1000, // in progress units
        COLORS: {
            BG_LAYER1: '#2c3e50',
            BG_LAYER2: 'rgba(52, 73, 94, 0.5)',
            EMPTY_OUTLINE: 'rgba(236, 240, 241, 0.1)',
            CONSTRUCTION_OUTLINE: '#95a5a6',
            BUILT_OUTLINE: '#f1c40f',
            HONEY_FILL_START: '#f39c12',
            HONEY_FILL_END: '#e67e22',
            BROOD_FILL: 'rgba(236, 240, 241, 0.8)',
            BEE_BODY: '#f1c40f',
            BEE_WING: 'rgba(236, 240, 241, 0.7)',
            QUEEN_BODY: '#e74c3c',
        }
    };

    // --- GLOBAL STATE ---
    let initialColonySize = parseInt(colonySizeSlider.value);
    let resourceAvailability = parseInt(resourceSlider.value);
    let bees = [];
    let queen;
    let grid = {};
    let mousePos = { x: 0, y: 0 };
    let lastTime = 0;
    
    // --- UTILITY FUNCTIONS ---
    const hexWidth = Math.sqrt(3) * CONFIG.HEX_SIZE;
    const hexHeight = 2 * CONFIG.HEX_SIZE;
    function hexToPixel(q, r) {
        const x = CONFIG.HEX_SIZE * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r);
        const y = CONFIG.HEX_SIZE * (3 / 2 * r);
        return { x: x + mainCanvas.width / 2, y: y + mainCanvas.height / 2 };
    }
    const hexDirections = [ { q: 1, r: 0 }, { q: 1, r: -1 }, { q: 0, r: -1 }, { q: -1, r: 0 }, { q: -1, r: 1 }, { q: 0, r: 1 } ];
    function getNeighbors(q, r) {
        return hexDirections.map(dir => ({ q: q + dir.q, r: r + dir.r }));
    }

    // --- CLASSES ---
    class HexCell {
        constructor(q, r) {
            this.q = q;
            this.r = r;
            this.key = `${q},${r}`;
            this.state = 'empty'; // empty, constructing, built, filling, brood, full
            this.progress = 0;
            this.pulse = 0; // for animation
            const { x, y } = hexToPixel(q, r);
            this.x = x;
            this.y = y;
        }

        draw(ctx) {
            let outlineColor = CONFIG.COLORS.EMPTY_OUTLINE;
            let lineWidth = 1;

            switch (this.state) {
                case 'constructing':
                    outlineColor = CONFIG.COLORS.CONSTRUCTION_OUTLINE;
                    lineWidth = 1 + this.progress * 2;
                    break;
                case 'built':
                case 'filling':
                case 'full':
                case 'brood':
                    outlineColor = CONFIG.COLORS.BUILT_OUTLINE;
                    lineWidth = 2;
                    break;
            }

            if (this.pulse > 0) {
                lineWidth += this.pulse * 2;
                outlineColor = 'white';
                this.pulse -= 0.02;
            }

            // Draw Hexagon Outline
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i + Math.PI / 6;
                const px = this.x + (CONFIG.HEX_SIZE - lineWidth) * Math.cos(angle);
                const py = this.y + (CONFIG.HEX_SIZE - lineWidth) * Math.sin(angle);
                ctx[i === 0 ? 'moveTo' : 'lineTo'](px, py);
            }
            ctx.closePath();
            ctx.strokeStyle = outlineColor;
            ctx.lineWidth = lineWidth;
            ctx.stroke();

            // Draw Fill Content
            if (this.state === 'filling' || this.state === 'full') {
                const honeyRadius = (CONFIG.HEX_SIZE * 0.8) * Math.sqrt(this.progress);
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, honeyRadius);
                gradient.addColorStop(0, CONFIG.COLORS.HONEY_FILL_START);
                gradient.addColorStop(1, CONFIG.COLORS.HONEY_FILL_END);
                ctx.beginPath();
                ctx.arc(this.x, this.y, honeyRadius, 0, 2 * Math.PI);
                ctx.fillStyle = gradient;
                ctx.fill();
            } else if (this.state === 'brood') {
                 const broodRadius = (CONFIG.HEX_SIZE * 0.7) * (this.progress / CONFIG.HATCH_TIME);
                 ctx.beginPath();
                 ctx.arc(this.x, this.y, broodRadius, 0, 2 * Math.PI);
                 ctx.fillStyle = CONFIG.COLORS.BROOD_FILL;
                 ctx.fill();
            }
        }
    }

    class Bee {
        constructor(id, isQueen = false) {
            this.id = id;
            this.isQueen = isQueen;
            this.x = mainCanvas.width / 2;
            this.y = mainCanvas.height / 2;
            this.target = { x: this.x, y: this.y };
            this.state = 'wandering';
            this.task = null; // { cell, progress }
            this.cargo = 0; // nectar cargo
            this.speed = isQueen ? CONFIG.QUEEN_SPEED : CONFIG.BEE_SPEED;
            this.size = isQueen ? CONFIG.BEE_SIZE * 1.5 : CONFIG.BEE_SIZE;
            this.color = isQueen ? CONFIG.COLORS.QUEEN_BODY : CONFIG.COLORS.BEE_BODY;
        }

        update(dt) {
            // Movement
            const dx = this.target.x - this.x;
            const dy = this.target.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 1) {
                this.x += (dx / dist) * this.speed * (dt * 60);
                this.y += (dy / dist) * this.speed * (dt * 60);
            }

            if (this.isQueen) this.updateQueen(dist);
            else this.updateWorker(dist, dt);
        }
        
        updateWorker(dist, dt) {
            switch (this.state) {
                case 'wandering':
                    if (dist < 5) this.findTask();
                    break;
                
                case 'gathering':
                    if (dist < 10) { // Reached edge of screen
                        this.cargo += resourceAvailability * 0.5 * (dt * 60);
                        if (this.cargo >= 100) {
                            this.cargo = 100;
                            this.state = 'wandering';
                        }
                    }
                    break;

                case 'building':
                case 'tending':
                case 'filling':
                    if (dist < 5) {
                        const cell = this.task.cell;
                        let rate = 1;
                        if (this.state === 'building') rate = CONFIG.BUILD_SPEED;
                        if (this.state === 'tending') rate = CONFIG.TEND_SPEED;
                        if (this.state === 'filling') {
                            const amount = Math.min(this.cargo, 1 * (dt*60));
                            cell.progress += amount / 100;
                            this.cargo -= amount;
                            if (this.cargo <= 0) this.state = 'wandering';
                        } else {
                            cell.progress += rate * (dt * 60);
                        }
                        
                        // Task completion
                        if (this.state === 'building' && cell.progress >= 100) {
                            cell.state = 'built';
                            cell.progress = 0;
                            cell.pulse = 1;
                            this.state = 'wandering';
                        } else if (this.state === 'tending' && cell.progress >= CONFIG.HATCH_TIME) {
                            cell.state = 'built';
                            cell.progress = 0;
                            cell.pulse = 1;
                            this.hatchBee();
                            this.state = 'wandering';
                        } else if (this.state === 'filling' && cell.progress >= 1) {
                            cell.state = 'full';
                            cell.progress = 1;
                            cell.pulse = 1;
                            this.state = 'wandering';
                        }
                    }
                    break;
            }
        }
        
        updateQueen(dist) {
             if (dist < 5) {
                // Lay egg in an empty built cell
                const builtCells = Object.values(grid).filter(c => c.state === 'built');
                if (builtCells.length > 0 && Math.random() < CONFIG.EGG_LAY_CHANCE) {
                    const cell = builtCells[Math.floor(Math.random() * builtCells.length)];
                    cell.state = 'brood';
                    cell.progress = 0;
                }
                // Wander near hive center
                const angle = Math.random() * 2 * Math.PI;
                const radius = Math.random() * 150;
                this.target = { x: mainCanvas.width / 2 + Math.cos(angle) * radius, y: mainCanvas.height / 2 + Math.sin(angle) * radius };
            }
        }
        
        findTask() {
            // Priority 1: Gather resources if empty
            if (this.cargo <= 0) {
                this.state = 'gathering';
                const angle = Math.random() * 2 * Math.PI;
                this.target = { 
                    x: mainCanvas.width/2 + Math.cos(angle) * (mainCanvas.width), 
                    y: mainCanvas.height/2 + Math.sin(angle) * (mainCanvas.height) 
                };
                return;
            }

            // Task priorities
            const tasks = [
                () => Object.values(grid).find(c => c.state === 'brood' && c.progress < CONFIG.HATCH_TIME), // Tend brood
                () => Object.values(grid).find(c => c.state === 'constructing'), // Help build
                () => Object.values(grid).find(c => c.state === 'built' || c.state === 'filling' && c.progress < 1), // Fill cell
                () => Object.values(grid).find(c => c.state === 'empty'), // Start new construction
            ];
            
            const taskStates = ['tending', 'building', 'filling', 'building'];
            
            for(let i = 0; i < tasks.length; i++) {
                const cell = tasks[i]();
                if(cell) {
                    this.state = taskStates[i];
                    if (this.state === 'building' && cell.state === 'empty') cell.state = 'constructing';
                    if (this.state === 'filling' && cell.state === 'built') cell.state = 'filling';
                    
                    this.task = { cell: cell };
                    this.target = { x: cell.x, y: cell.y };
                    return;
                }
            }
            
            // Wander if no tasks
            this.target = { x: Math.random() * mainCanvas.width, y: Math.random() * mainCanvas.height };
        }
        
        hatchBee() {
            if (bees.length < 300) { // Cap colony size for performance
                bees.push(new Bee(bees.length));
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);

            // Wings
            const wingAngle = Date.now() * 0.05 + this.id;
            const wingLength = this.size * 1.8;
            ctx.strokeStyle = CONFIG.COLORS.BEE_WING;
            ctx.lineWidth = this.isQueen ? 3 : 2;
            ctx.beginPath();
            ctx.moveTo(0,0);
            ctx.lineTo(Math.cos(wingAngle) * wingLength, Math.sin(wingAngle) * wingLength);
            ctx.moveTo(0,0);
            ctx.lineTo(Math.cos(wingAngle + Math.PI) * wingLength, Math.sin(wingAngle + Math.PI) * wingLength);
            ctx.stroke();

            // Body
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.ellipse(0, 0, this.size * 1.2, this.size, 0, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.restore();
        }
    }

    // --- SIMULATION LOGIC ---
    function expandHive() {
        const builtCells = Object.values(grid).filter(c => c.state !== 'empty' && c.state !== 'constructing');
        if (builtCells.length === 0) return;

        const cell = builtCells[Math.floor(Math.random() * builtCells.length)];
        const neighbors = getNeighbors(cell.q, cell.r);
        for (const n of neighbors) {
            const key = `${n.q},${n.r}`;
            if (!grid[key]) {
                grid[key] = new HexCell(n.q, n.r);
            }
        }
    }

    function updateStats() {
        const cellCount = Object.keys(grid).length;
        const honeyProgress = Object.values(grid)
            .filter(c => c.state === 'filling' || c.state === 'full')
            .reduce((sum, c) => sum + c.progress, 0);
        const broodCount = Object.values(grid).filter(c => c.state === 'brood').length;

        statsDiv.innerHTML = `
            <p>Bees: <span>${bees.length}</span></p>
            <p>Cells: <span>${cellCount}</span></p>
            <p>Honey Units: <span>${Math.floor(honeyProgress)}</span></p>
            <p>Brood: <span>${broodCount}</span></p>
        `;
    }

    // --- DRAWING ---
    function drawBackground() {
        bgCtx.fillStyle = CONFIG.COLORS.BG_LAYER1;
        bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
        
        const parallaxFactor = 0.02;
        const offsetX = (mousePos.x - bgCanvas.width / 2) * parallaxFactor;
        const offsetY = (mousePos.y - bgCanvas.height / 2) * parallaxFactor;

        bgCtx.fillStyle = CONFIG.COLORS.BG_LAYER2;
        for (let i = 0; i < 50; i++) {
            const x = (i * 37) % bgCanvas.width + offsetX;
            const y = (i * 91) % bgCanvas.height + offsetY;
            bgCtx.beginPath();
            bgCtx.arc(x, y, i % 5 + 1, 0, 2 * Math.PI);
            bgCtx.fill();
        }
    }

    function drawVignette() {
        const gradient = mainCtx.createRadialGradient(
            mainCanvas.width / 2, mainCanvas.height / 2, mainCanvas.width / 3,
            mainCanvas.width / 2, mainCanvas.height / 2, mainCanvas.width / 2 + 100
        );
        gradient.addColorStop(0, 'rgba(0,0,0,0)');
        gradient.addColorStop(1, 'rgba(0,0,0,0.4)');
        mainCtx.fillStyle = gradient;
        mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
    }

    // --- MAIN LOOP ---
    function gameLoop(timestamp) {
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        // Update
        [...bees, queen].forEach(b => b.update(dt));
        if (Math.random() < 0.1) expandHive();
        updateStats();

        // Draw
        mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
        drawBackground();
        
        Object.values(grid).forEach(cell => cell.draw(mainCtx));
        [...bees, queen].forEach(b => b.draw(mainCtx));
        drawVignette();

        requestAnimationFrame(gameLoop);
    }

    // --- INITIALIZATION ---
    function setup() {
        const container = document.getElementById('simulationContainer');
        const size = Math.min(window.innerWidth * 0.95, window.innerHeight * 0.8, 1000);
        container.style.width = `${size}px`;
        container.style.height = `${size}px`;
        bgCanvas.width = mainCanvas.width = size;
        bgCanvas.height = mainCanvas.height = size;
    }

    function init() {
        grid = {};
        const centerCell = new HexCell(0, 0);
        centerCell.state = 'built';
        grid[centerCell.key] = centerCell;
        
        bees = [];
        for (let i = 0; i < initialColonySize; i++) {
            bees.push(new Bee(i));
        }
        queen = new Bee(999, true);

        expandHive();
    }

    // --- EVENT LISTENERS ---
    colonySizeSlider.addEventListener('input', e => {
        initialColonySize = parseInt(e.target.value);
        colonyValueSpan.textContent = initialColonySize;
    });
    resourceSlider.addEventListener('input', e => {
        resourceAvailability = parseInt(e.target.value);
        resourceValueSpan.textContent = resourceAvailability;
    });
    resetButton.addEventListener('click', init);
    window.addEventListener('resize', () => {
        setup();
        drawBackground(); // Redraw static parts on resize
    });
    document.addEventListener('mousemove', e => {
        const rect = bgCanvas.getBoundingClientRect();
        mousePos.x = e.clientX - rect.left;
        mousePos.y = e.clientY - rect.top;
    });

    // --- START ---
    setup();
    init();
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);

</script>
</body>
</html>
